import gzip
from datetime import datetime
from os import listdir, mkdir, path as op, remove, sep
from re import search
from tempfile import NamedTemporaryFile
from time import gmtime, strftime


class StorageTools(object):
    TIMESTAMP = strftime("%Y%m%d%H%M%S", gmtime())

    @staticmethod
    def get_timestamp(name):
        """
        Gets the timestamp from a given file name
        :param name: (string) Name of a file generated by AlchemyDumps
        :return: (string) The backup numeric id (in case of success) or False
        """
        pattern = r"(.*)(-)(?P<timestamp>[\d]{14})(-)(.*)(.gz)"
        match = search(pattern, name)
        return match.group("timestamp") if match else False

    @staticmethod
    def parse_timestamp(timestamp):
        """Transforms a timestamp ID in a humanized date"""
        date_parsed = datetime.strptime(timestamp, "%Y%m%d%H%M%S")
        return date_parsed.strftime("%b %d, %Y at %H:%M:%S")


class Storage(StorageTools):
    pass


class LocalStorage(Storage):
    """Manage backup directory and files in local file system"""

    def __init__(self, backup_path):
        self.path = self.normalize_path(backup_path)

    @staticmethod
    def normalize_path(path):
        """
        Creates the backup directory (if needed) and returns its absolute path
        :return: (str) Absolue path to the backup directory
        """
        if not op.exists(path):
            mkdir(path)
        return op.abspath(path) + sep

    def get_files(self):
        """List all files in the backup directory"""
        for name in listdir(self.path):
            is_file = op.isfile(op.join(self.path, name))
            has_timestamp = self.get_timestamp(name)
            if is_file and has_timestamp:
                yield name

    def create_file(self, name, contents):
        """
        Creates a gzip file
        :param name: (str) Name of the file to be created (without path)
        :param contents: (bytes) Contents to be written in the file
        :return: (str) path of the created file
        """
        file_path = op.join(self.path, name)
        with gzip.open(file_path, "wb") as handler:
            handler.write(contents)
        return file_path

    def read_file(self, name):
        """
        Reads the contents of a gzip file
        :param name: (str) Name of the file to be read (without path)
        :return: (bytes) Content of the file
        """
        file_path = op.join(self.path, name)
        with gzip.open(file_path, "rb") as handler:
            return handler.read()

    def delete_file(self, name):
        """
        Delete a file
        :param name: (str) Name of the file to be deleted (without path)
        """
        remove(op.join(self.path, name))


class FtpStorage(Storage):
    """Manage backup files in a remote file system via FTP"""

    def __init__(self, ftp):
        """Receives a Python FTP class instance"""
        self.ftp = ftp
        self.path = self.normalize_path()

    def normalize_path(self):
        """Add missing slash to the end of the FTP url to be used in stdout"""
        url = "ftp://{}{}".format(self.ftp.host, self.ftp.pwd())
        return url if url.endswith("/") else url + "/"

    def get_files(self):
        """List all files in the backup directory"""
        files = self.ftp.nlst()
        for name in files:
            if self.get_timestamp(name):
                yield name

    def create_file(self, name, contents):
        """
        Creates a gzip file
        :param name: (str) Name of the file to be created (without path)
        :param contents: (bytes) Contents to be written in the file
        :return: (str) path of the created file
        """
        # write a tmp file
        tmp = NamedTemporaryFile()
        with gzip.open(tmp.name, "wb") as handler:
            handler.write(contents)

        # send it to the FTP server
        self.ftp.storbinary("STOR {}".format(name), open(tmp.name, "rb"))
        return "{}{}".format(self.path, name)

    def read_file(self, name):
        """
        Reads the contents of a gzip file
        :param name: (str) Name of the file to be read (without path)
        :return: (bytes) Content of the file
        """
        tmp = NamedTemporaryFile()
        with open(tmp.name, "wb") as handler:
            self.ftp.retrbinary("RETR {}".format(name), handler.write)
        with gzip.open(tmp.name, "rb") as handler:
            return handler.read()

    def delete_file(self, name):
        """
        Delete a file
        :param name: (str) Name of the file to be deleted (without path)
        """
        self.ftp.delete(name)


class S3Storage(Storage):
    pass
