import gzip
from datetime import datetime
from os import listdir, mkdir, path as op, remove, sep
from re import search
from tempfile import NamedTemporaryFile
from time import gmtime, strftime
from dataclasses import dataclass, field
from typing import Generator
from ftplib import FTP


# class StorageTools(object):
#     TIMESTAMP = strftime("%Y%m%d%H%M%S", gmtime())
#
#     @staticmethod
#     def get_timestamp(name):
#         """
#         Gets the timestamp from a given file name
#         :param name: (string) Name of a file generated by AlchemyDumps
#         :return: (string) The backup numeric id (in case of success) or False
#         """
#         pattern = r"(.*)(-)(?P<timestamp>[\d]{14})(-)(.*)(.gz)"
#         match = search(pattern, name)
#         return match.group("timestamp") if match else False
#
#     @staticmethod
#     def parse_timestamp(timestamp):
#         """Transforms a timestamp ID in a humanized date"""
#         date_parsed = datetime.strptime(timestamp, "%Y%m%d%H%M%S")
#         return date_parsed.strftime("%b %d, %Y at %H:%M:%S")


@dataclass
class Storage(object):
    backup_path: str
    prefix: str = "db-backup"

    def __post_init__(self):
        self.backup_path = self.normalize_path(self.backup_path)

    @staticmethod
    def normalize_path(path: str) -> str:
        pass

    def get_files(self) -> Generator:
        pass

    def create_file(self, name: str, contents: bytes) -> str:
        pass

    def read_file(self, name: str):
        pass

    def delete_file(self, name: str) -> None:
        pass


@dataclass
class LocalStorage(Storage):
    local_dir: str = "alchemydumps-backup"

    @staticmethod
    def normalize_path(path: str) -> str:
        if not op.exists(path):
            mkdir(path)
        return op.abspath(path) + sep

    def get_files(self) -> Generator:
        for name in listdir(self.path):
            is_file = op.isfile(op.join(self.path, name))
            has_timestamp = self.get_timestamp(name)
            if is_file and has_timestamp:
                yield name

    def create_file(self, name: str, contents: bytes) -> str:
        file_path = op.join(self.path, name)
        with gzip.open(file_path, "wb") as handler:
            handler.write(contents)
        return file_path

    def read_file(self, name: str) -> bytes:
        file_path = op.join(self.path, name)
        with gzip.open(file_path, "rb") as handler:
            return handler.read()

    def delete_file(self, name: str) -> None:
        remove(op.join(self.path, name))


@dataclass
class FtpStorage(Storage):
    ftp_server: str = None
    ftp_user: str = None
    ftp_password: str = None
    ftp_path: str = None

    def normalize_path(self):
        """Add missing slash to the end of the FTP url to be used in stdout"""
        url = "ftp://{}{}".format(self.ftp.host, self.ftp.pwd())
        return url if url.endswith("/") else url + "/"

    def get_files(self) -> Generator:
        """List all files in the backup directory"""
        files = self.ftp.nlst()
        for name in files:
            if self.get_timestamp(name):
                yield name

    def create_file(self, name: str, contents: bytes) -> str:
        path = self.normalize_path()
        tmp = NamedTemporaryFile()
        with gzip.open(tmp.name, "wb") as handler:
            handler.write(contents)

        # send it to the FTP server
        self.ftp.storbinary("STOR {}".format(name), open(tmp.name, "rb"))
        return "{}{}".format(path, name)

    def read_file(self, name: str) -> bytes:
        tmp = NamedTemporaryFile()
        with open(tmp.name, "wb") as handler:
            self.ftp.retrbinary("RETR {}".format(name), handler.write)
        with gzip.open(tmp.name, "rb") as handler:
            return handler.read()

    def delete_file(self, name: str) -> None:
        self.ftp.delete(name)


class S3Storage(Storage):
    s3_bucket_name: str = None
    s3_bucket_domain: str = None
    s3_bucket_path: str = None
